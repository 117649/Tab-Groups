// VERSION 1.0.0

'use strict';

const Cu = Components.utils;
const Ci = Components.interfaces;

const console = Cu.import("resource://gre/modules/devtools/Console.jsm", {}).console;

const TabView = {};

let active = true;

const frames = new Set();


//console.log("tabgroups content sandbox load");

function shutdown() {
  active = false;
  for(let frame of frames) {
    removeFrame(frame);
  }

  //console.log("tabgroups content sandbox shutdown", frames.size);
  frames.clear()
}

TabView.handleEvent = function(e) {
  if(!active) {return;}

  let frameMM = e.currentTarget;

  switch(e.type) {
  // Sends a synchronous message when the "onDOMWillOpenModalDialog" event is fired right before a modal dialog will be opened by the current page.
  case 'DOMWillOpenModalDialog':
    // (e.isTrusted == true) when the event is generated by a user action and does not originate from a script.
    if(!e.isTrusted) { break; }

    // we're intentionally sending a synchronous message to handle this event as quickly as possible,
    // to switch the selected tab and hide the tabview before the modal dialog is shown
    frameMM.sendSyncMessage("tabgroups:DOMWillOpenModalDialog", {});
    break;

  case 'MozAfterPaint':
    // Sends an asynchronous message when the "onMozAfterPaint" event is fired.
    if(e.clientRects.length) {
      frameMM.sendAsyncMessage("tabgroups:MozAfterPaint", {});
    }
    break;

  case 'timeupdate':
    // <video> may not fire paint events during playback.
    // fake paint events so we can still update thumbnails
    if(e.target.localName == "video") {
      frameMM.sendAsyncMessage("tabgroups:MozAfterPaint", {});
    }
    break;

  case 'load':
    frameMM.sendAsyncMessage("tabgroups:documentLoaded", {});
    break;

  }


};

TabView.receiveMessage = function(m) {
  if(!active) {return;}

  let name = m.name;
  let frameMM = m.target;
  let content = frameMM.content;
  let document = content && content.document;

  switch(name) {
  // Checks if the currently active document is loaded.
  case 'tabgroups:isDocumentLoaded':
    let webProgress = frameMM.docShell.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebProgress);
    let isLoaded = (document && document.readyState != "uninitialized" && !webProgress.isLoadingDocument);

    frameMM.sendAsyncMessage("tabgroups:isDocumentLoaded", {result: isLoaded});
    break;

    // Checks if the currently active document is an image document or not.
  case 'tabgroups:isImageDocument':
    let isImageDocument = (document && document instanceof Ci.nsIImageDocument);

    frameMM.sendAsyncMessage("tabgroups:isImageDocument", {result: isImageDocument});
    break;

  case 'tabgroups:waitForDocumentLoad':
    frameMM.addEventListener("load", TabView);
    break;
  }

};

function frameUnload(e) {
  if(!(e.target instanceof Ci.nsIMessageListenerManager))
    return;
  removeFrame(e.target)
}

function removeFrame(frame) {
  //console.log("removing frame");
  frames.delete(frame);

  frame.removeEventListener("DOMWillOpenModalDialog", TabView);
  frame.removeEventListener("MozAfterPaint", TabView);
  frame.removeEventListener("timeupdate", TabView, true);
  frame.removeEventListener("load", TabView);
  frame.removeEventListener("unload", frameUnload);


  frame.removeMessageListener("tabgroups:isDocumentLoaded", TabView);
  frame.removeMessageListener("tabgroups:isImageDocument", TabView);
  frame.removeMessageListener("tabgroups:waitForDocumentLoad", TabView);

}

function registerFrame(frame) {
  //console.log("adding frame")
  frames.add(frame)

  frame.addEventListener("unload", frameUnload);

  frame.addEventListener("DOMWillOpenModalDialog", TabView);
  frame.addEventListener("MozAfterPaint", TabView);
  frame.addEventListener("timeupdate", TabView, true);

  frame.addMessageListener("tabgroups:isDocumentLoaded", TabView);
  frame.addMessageListener("tabgroups:isImageDocument", TabView);
  frame.addMessageListener("tabgroups:waitForDocumentLoad", TabView);
}
